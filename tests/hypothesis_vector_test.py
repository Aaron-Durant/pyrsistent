"""
Hypothesis-based tests for pvector.
"""

import gc
from random import randint

from pytest import fixture

from pyrsistent import pvector

from hypothesis import strategies as st, assume
from hypothesis.stateful import RuleBasedStateMachine, Bundle, rule


class TestObject(object):
    """
    An object that might catch reference count errors sometimes.
    """
    def __init__(self):
        self.id = id(self)

    def __repr__(self):
        return "<%s>" % (self.id,)

    def __del__(self):
        # If self is a dangling memory reference this check might fail. Or
        # segfault :)
        if self.id != id(self):
            raise RuntimeError()


@fixture(scope="module")
def gc_when_done(request):
    request.addfinalizer(gc.collect)


def test_setup(gc_when_done):
    """
    Ensure we GC when tests finish.
    """


# Pairs of a list and corresponding pvector:
PVectorAndLists = st.lists(st.builds(TestObject), average_size=10).map(
    lambda l: (l, pvector(l)))


class PVectorBuilder(RuleBasedStateMachine):
    """
    Build a list and matching pvector step-by-step.

    In each step in the state machine we do same operation on a list and
    on a pvector, and then when we're done we compare the two.
    """
    sequences = Bundle("sequences")

    @rule(target=sequences, start=PVectorAndLists)
    def initial_value(self, start):
        """
        Some initial values generated by a hypothesis strategy.
        """
        return start

    @rule(target=sequences, former=sequences)
    def append(self, former):
        """
        Append an item to the pair of sequences.
        """
        l, pv = former
        obj = TestObject()
        l2 = l[:]
        l2.append(obj)
        return l2, pv.append(obj)

    @rule(target=sequences, start=sequences, end=sequences)
    def extend(self, start, end):
        """
        Extend a pair of sequences with another pair of sequences.
        """
        l, pv = start
        l2, pv2 = end
        # compare() has O(N**2) behavior, so don't want too-large lists:
        assume(len(l) + len(l2) < 50)
        l3 = l[:]
        l3.extend(l2)
        return l3, pv.extend(pv2)

    @rule(target=sequences, former=sequences)
    def remove(self, former):
        """
        Remove an item from the sequences.
        """
        l, pv = former
        assume(l)
        l2 = l[:]
        i = randint(0, len(l) - 1)
        del l2[i]
        return l2, pv.delete(i)

    @rule(target=sequences, former=sequences)
    def set(self, former):
        """
        Overwrite an item in the sequence.
        """
        l, pv = former
        assume(l)
        l2 = l[:]
        i = randint(0, len(l) - 1)
        obj = TestObject()
        l2[i] = obj
        return l2, pv.set(i, obj)

    @rule(pair=sequences)
    def compare(self, pair):
        """
        The list and pvector must match.
        """
        l, pv = pair
        assert l == pv
        assert len(l) == len(pv)
        length = len(l)
        for i in range(length):
            assert l[i] == pv[i]
        for i in range(length):
            for j in range(i, length):
                assert l[i:j] == pv[i:j]


PVectorBuilderTests = PVectorBuilder.TestCase
# Reduce number of tested examples:
PVectorBuilderTests.settings.max_examples = 50
