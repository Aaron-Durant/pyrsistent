"""
Hypothesis-based tests for pvector.
"""

import gc
from random import randint
from functools import wraps

from pytest import fixture

from pyrsistent import pvector

from hypothesis import strategies as st, assume
from hypothesis.stateful import RuleBasedStateMachine, Bundle, rule


class TestObject(object):
    """
    An object that might catch reference count errors sometimes.
    """
    def __init__(self):
        self.id = id(self)

    def __repr__(self):
        return "<%s>" % (self.id,)

    def __del__(self):
        # If self is a dangling memory reference this check might fail. Or
        # segfault :)
        if self.id != id(self):
            raise RuntimeError()


@fixture(scope="module")
def gc_when_done(request):
    request.addfinalizer(gc.collect)


def test_setup(gc_when_done):
    """
    Ensure we GC when tests finish.
    """


# Pairs of a list and corresponding pvector:
PVectorAndLists = st.lists(st.builds(TestObject), average_size=10).map(
    lambda l: (l, pvector(l)))


def verify_inputs_unmodified(original):
    """
    Decorator that asserts that the wrapped function does not modify its
    inputs.
    """
    def to_tuples(pairs):
        return [(tuple(l), tuple(pv)) for (l, pv) in pairs]

    @wraps(original)
    def wrapper(self, **kwargs):
        inputs = kwargs.values()
        tuple_inputs = to_tuples(inputs)
        try:
            return original(self, **kwargs)
        finally:
            # Ensure inputs were unmodified:
            assert to_tuples(inputs) == tuple_inputs
    return wrapper


class PVectorBuilder(RuleBasedStateMachine):
    """
    Build a list and matching pvector step-by-step.

    In each step in the state machine we do same operation on a list and
    on a pvector, and then when we're done we compare the two.
    """
    sequences = Bundle("sequences")

    @rule(target=sequences, start=PVectorAndLists)
    def initial_value(self, start):
        """
        Some initial values generated by a hypothesis strategy.
        """
        return start

    @rule(target=sequences, former=sequences)
    @verify_inputs_unmodified
    def append(self, former):
        """
        Append an item to the pair of sequences.
        """
        l, pv = former
        obj = TestObject()
        l2 = l[:]
        l2.append(obj)
        return l2, pv.append(obj)

    @rule(target=sequences, start=sequences, end=sequences)
    @verify_inputs_unmodified
    def extend(self, start, end):
        """
        Extend a pair of sequences with another pair of sequences.
        """
        l, pv = start
        l2, pv2 = end
        # compare() has O(N**2) behavior, so don't want too-large lists:
        assume(len(l) + len(l2) < 50)
        l3 = l[:]
        l3.extend(l2)
        return l3, pv.extend(pv2)

    @rule(target=sequences, former=sequences)
    @verify_inputs_unmodified
    def remove(self, former):
        """
        Remove an item from the sequences.
        """
        l, pv = former
        assume(l)
        l2 = l[:]
        i = randint(0, len(l) - 1)
        del l2[i]
        return l2, pv.delete(i)

    @rule(target=sequences, former=sequences)
    @verify_inputs_unmodified
    def set(self, former):
        """
        Overwrite an item in the sequence.
        """
        l, pv = former
        assume(l)
        l2 = l[:]
        i = randint(0, len(l) - 1)
        obj = TestObject()
        l2[i] = obj
        return l2, pv.set(i, obj)

    @rule(target=sequences, former=sequences)
    @verify_inputs_unmodified
    def subset(self, former):
        """
        A subset of the previous sequence.
        """
        l, pv = former
        assume(l)
        i = randint(0, len(l) - 1)
        j = randint(i, len(l) - 1)
        return l[i:j], pv[i:j]

    @rule(pair=sequences)
    @verify_inputs_unmodified
    def compare(self, pair):
        """
        The list and pvector must match.
        """
        l, pv = pair
        # compare() has O(N**2) behavior, so don't want too-large lists:
        assume(len(l) < 50)
        assert l == pv
        assert len(l) == len(pv)
        length = len(l)
        for i in range(length):
            assert l[i] == pv[i]
        for i in range(length):
            for j in range(i, length):
                assert l[i:j] == pv[i:j]


PVectorBuilderTests = PVectorBuilder.TestCase
# Reduce number of tested examples:
PVectorBuilderTests.settings.max_examples = 50
